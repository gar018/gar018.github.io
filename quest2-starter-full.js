class Renderer{constructor(canvas){this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:56/255,b:101/255,a:1};}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this._canvas.style.transformOrigin="center";this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});for(const obj of this._objects){obj?.render(pass);}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class FilteredRenderer extends Renderer{constructor(canvas){super(canvas);this._filters=[];}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat="rgba8unorm";this._context.configure({device:this._device,format:this._canvasFormat,});this._shaderModule=this._device.createShaderModule({label:"Image Filter Renderer Shader",code:`
      @vertex
      fn vertexMain(@builtin(vertex_index) vIdx: u32) -> @builtin(position) vec4f {
        var pos = array<vec2f, 6>(
          vec2f(-1, -1), vec2f(1, -1), vec2f(-1, 1),
          vec2f(-1, 1), vec2f(1, -1), vec2f(1, 1)
        );
        return vec4f(pos[vIdx], 0, 1);
      }
      
      @group(0) @binding(0) var inTexture: texture_2d<f32>;
      @group(0) @binding(1) var inSampler: sampler;
      
      @fragment
      fn fragmentMain(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
        let uv = fragCoord.xy / vec2f(textureDimensions(inTexture, 0));
        return textureSample(inTexture, inSampler, uv);
      }
      `});this._pipeline=this._device.createRenderPipeline({label:"Image Filter Renderer Pipeline",layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._sampler=this._device.createSampler({label:"Image Filter Renderer Sampler",magFilter:"linear",minFilter:"linear"});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;let imgSize={width:width,height:height};this._textures=[];this._textures.push(this._device.createTexture({size:imgSize,format:this._canvasFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,}),this._device.createTexture({size:imgSize,format:this._canvasFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,}),);for(const obj of this._filters){obj._imgWidth=this._textures[0].width;obj._imgHeight=this._textures[0].height;obj.updateGeometry();}
super.resizeCanvas();}
async appendFilterObject(obj){await obj.init();obj._imgWidth=this._textures[0].width;obj._imgHeight=this._textures[0].height;obj.updateGeometry();this._filters.push(obj);}
render(){super.renderToSelectedView(this._textures[0].createView());for(let i=0;i<this._filters.length;++i){let encoder=this._device.createCommandEncoder();const computePass=encoder.beginComputePass();this._filters[i].createBindGroup(this._textures[i%2],this._textures[(i+1)%2]);this._filters[i].compute(computePass);computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:this._context.getCurrentTexture().createView(),clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});const bindGroup=this._device.createBindGroup({label:"Image Filter Renderer Bind Group",layout:this._pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this._textures[this._filters.length%2].createView()},{binding:1,resource:this._sampler}],});pass.setPipeline(this._pipeline);pass.setBindGroup(0,bindGroup);pass.draw(6);pass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){throw new Error("Method 'createShaders()' must be implemented.");}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}}
class Standard2DFullScreenObject extends SceneObject{constructor(device,canvasFormat,img){super(device,canvasFormat);this._img=new Image();this._img.src=img;}
async createGeometry(){await this._img.decode();this._bitmap=await createImageBitmap(this._img);this._texture=this._device.createTexture({label:"Texture "+this.getName(),size:[this._bitmap.width,this._bitmap.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,});this._device.queue.copyExternalImageToTexture({source:this._bitmap},{texture:this._texture},[this._bitmap.width,this._bitmap.height]);this._sampler=this._device.createSampler({magFilter:"linear",minFilter:"linear"});}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_fullscreen.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._bindGroup=this._device.createBindGroup({layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this._texture.createView(),},{binding:1,resource:this._sampler,}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setBindGroup(0,this._bindGroup);pass.draw(6,1,0,0);}
async createComputePipeline(){}
compute(pass){}}
class Standard2DPGAPosedVertexColorObject extends SceneObject{constructor(device,canvasFormat,vertices,pose){super(device,canvasFormat);this._vertices=vertices;this._pose=pose;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,},{shaderLocation:1,format:"float32x4",offset:2*Float32Array.BYTES_PER_ELEMENT,}],};this._poseBuffer=this._device.createBuffer({label:"Pose "+this.getName(),size:this._pose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
updateGeometry(){this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2dpgacolored.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._bindGroup=this._device.createBindGroup({label:"Render Bind Group "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._poseBuffer},}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroup);pass.draw(this._vertices.length/6);}
async createComputePipeline(){}
compute(pass){}}
class LineStrip2DVertexObject extends SceneObject{constructor(device,canvasFormat,vertices){super(device,canvasFormat);this._vertices=vertices;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,}],};}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2d.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]},primitive:{topology:'line-strip'}});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.draw(this._vertices.length/2);}
async createComputePipeline(){}
compute(pass){}}
class DemoTreeObject extends Standard2DPGAPosedVertexColorObject{constructor(device,canvasFormat,pose){let _vertices=new Float32Array([-0.025,-0.15,77.0/255,40.0/255,40.0/255,1,-0.025,-0.45,77.0/255,40.0/255,40.0/255,1,0.025,-0.45,77.0/255,40.0/255,40.0/255,1,-0.025,-0.15,77.0/255,40.0/255,40.0/255,1,0.025,-0.45,77.0/255,40.0/255,40.0/255,1,0.025,-0.15,77.0/255,40.0/255,40.0/255,1,0,0.05,34.0/255,110.0/255,34.0/255,1,-0.1,-0.15,34.0/255,90.0/255,34.0/255,1,0.1,-0.15,34.0/255,90.0/255,34.0/255,1,0,0.10,34.0/255,110.0/255,34.0/255,1,-0.1,-0.10,34.0/255,90.0/255,34.0/255,1,0.1,-0.10,34.0/255,90.0/255,34.0/255,1,0,0.15,34.0/255,110.0/255,34.0/255,1,-0.1,-0.05,34.0/255,90.0/255,34.0/255,1,0.1,-0.05,34.0/255,90.0/255,34.0/255,1,0,0.2,34.0/255,110.0/255,34.0/255,1,-0.1,0.0,34.0/255,90.0/255,34.0/255,1,0.1,0.0,34.0/255,90.0/255,34.0/255,1,]);super(device,canvasFormat,_vertices,pose);this._interval=20;this._t=0;this._step=1;this._pose0=[1,-45/90,0,1,0.5,0.5];this._pose1=[1,45/90,0,-1,0.5,0.5];}
updateGeometry(){this._pose[0]=this._pose0[0]*(1-this._t/this._interval)+this._pose1[0]*this._t/this._interval;this._pose[1]=this._pose0[1]*(1-this._t/this._interval)+this._pose1[1]*this._t/this._interval;this._pose[2]=this._pose0[2]*(1-this._t/this._interval)+this._pose1[2]*this._t/this._interval;this._pose[3]=this._pose0[3]*(1-this._t/this._interval)+this._pose1[3]*this._t/this._interval;this._t+=this._step;if(this._t>=this._interval){this._step=-1;}
else if(this._t<=0){this._step=1;}
super.updateGeometry();}}
class PlanetObject extends Standard2DPGAPosedVertexColorObject{constructor(device,canvasFormat,pose,orbitsAround,size,color,orbitalPeriod,distance,eccentricity=0.1){var outArray=[];let triangleCount=24;for(let i=0;i<triangleCount;i++){let theta_1=(2*Math.PI*i)/triangleCount;let theta_2=(2*Math.PI*(i+1))/triangleCount;let a=[0,0].concat(color);let b=[size*Math.cos(theta_1),size*Math.sin(theta_1)].concat(color);let c=[size*Math.cos(theta_2),size*Math.sin(theta_2)].concat(color);outArray=outArray.concat(a).concat(b).concat(c);}
let _vertices=new Float32Array(outArray);super(device,canvasFormat,_vertices,pose);this._orbitsAround=orbitsAround;this._orbitalPeriod=orbitalPeriod*10.0;this._distance=distance;this._eccentricity=eccentricity;this._t=0;this._step=1;}
updateGeometry(){this._pose[2]=this._orbitsAround[2]+this._distance*Math.cos(2*Math.PI*this._t/this._orbitalPeriod);this._pose[3]=this._orbitsAround[3]+(this._distance+this._eccentricity)*Math.sin(2*Math.PI*this._t/this._orbitalPeriod);this._t=(this._t+this._step)%this._orbitalPeriod;super.updateGeometry();}}
class PGA2D{static geometricProduct(a,b){return[a[0]*b[0]-a[1]*b[1],a[0]*b[1]+a[1]*b[0],a[0]*b[2]+a[1]*b[3]+a[2]*b[0]-a[3]*b[1],a[0]*b[3]-a[1]*b[2]+a[2]*b[1]+a[3]*b[0]];}
static reverse(a){return[a[0],-a[1],-a[2],-a[3]];}
static applyMotor(p,m){return PGA2D.geometricProduct(m,PGA2D.geometricProduct(p,PGA2D.reverse(m)));}
static motorNorm(m){return Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]+m[3]*m[3]);}
static createTranslator(dx,dy){return[1,0,dy/2,-dx/2]}
static createRotor(angle,cx=0,cy=0){return[Math.cos(angle/2),-Math.sin(angle/2),-cx*Math.sin(angle/2),-cy*Math.sin(angle/2)];}
static normalizeMotor(m){let mnorm=PGA2D.motorNorm(m);if(mnorm==0.0){return[1,0,0,0];}
return[m[0]/mnorm,m[1]/mnorm,m[2]/mnorm,m[3]/mnorm];}
static applyMotorToPoint(p,m){let new_p=PGA2D.applyMotor([0,1,p[0],p[1]],m);return[new_p[2]/new_p[1],new_p[3]/new_p[1]];};}
class ImageFilterObject extends SceneObject{async createGeometry(){}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_computenothing.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
updateGeometry(){}
async createRenderPipeline(){}
render(pass){}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Image Filter Pipeline "+this.getName(),layout:"auto",compute:{module:this._shaderModule,entryPoint:"computeMain",}});}
createBindGroup(inTexture,outTexture){this._bindGroup=this._device.createBindGroup({label:"Image Filter Bind Group",layout:this._computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:inTexture.createView()},{binding:1,resource:outTexture.createView()}],});this._wgWidth=Math.ceil(inTexture.width);this._wgHeight=Math.ceil(inTexture.height);}
compute(pass){pass.setPipeline(this._computePipeline);pass.setBindGroup(0,this._bindGroup);pass.dispatchWorkgroups(this._wgWidth,this._wgHeight);}}
class ImageGrayscaleFilterObject extends ImageFilterObject{async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_computegrayscale.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}}
async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const renderer=new FilteredRenderer(canvasTag);await renderer.init();await renderer.appendSceneObject(new Standard2DFullScreenObject(renderer._device,renderer._canvasFormat,"/assets/space_image.jpeg"));let applyGrayscale=false;if(applyGrayscale){await renderer.appendFilterObject(new ImageGrayscaleFilterObject(renderer._device,renderer._canvasFormat,canvasTag));}
console.log("NOTE: I also have implemented a grayscale filter in this quest! To activate change the \'applyGrayscale\' boolean to true.");var defaultPose=[1,0,0,0,1,1];function createPolygon(r,color=[1,1,1,1],triangleCount=10){let POSITION_DIMENSIONS=2;let COLOR_DIMENSIONS=4;var outArray=[];for(let i=0;i<triangleCount;i++){let theta_1=(2*Math.PI*i)/triangleCount;let theta_2=(2*Math.PI*(i+1))/triangleCount;let a=[0,0].concat(color);let b=[r*Math.cos(theta_1),r*Math.sin(theta_1)].concat(color);let c=[r*Math.cos(theta_2),r*Math.sin(theta_2)].concat(color);outArray=outArray.concat(a).concat(b).concat(c);}
var out=new Float32Array(outArray);return out;}
var sunFlare=createPolygon(0.115,[255.0/255,75.0/255,0.0/255,1]);var sunFlarePose=new Float32Array(defaultPose);await renderer.appendSceneObject(new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,sunFlare,sunFlarePose));var sun=createPolygon(0.1,[255.0/255,125.0/255,30.0/255,1]);var sunPose=new Float32Array(defaultPose);await renderer.appendSceneObject(new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,sun,sunPose));var mercuryPose=new Float32Array([1,0,0,0,1,1]);let MERCURY_SIZE=0.01;let MERCURY_COLOR=[175.0/255,175.0/255,175.0/255,1];let MERCURY_ORBITAL_PERIOD=88.0/365.0*60.0;let MERCURY_DISTANCE=0.07;await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,mercuryPose,sunPose,MERCURY_SIZE,MERCURY_COLOR,MERCURY_ORBITAL_PERIOD,MERCURY_DISTANCE));var venusPose=new Float32Array([1,0,0,0,1,1]);let VENUS_SIZE=0.02;let VENUS_COLOR=[255.0/255,200.0/255,100.0/255,1];let VENUS_ORBITAL_PERIOD=225.0/365.0*60.0;let VENUS_DISTANCE=0.09;await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,venusPose,sunPose,VENUS_SIZE,VENUS_COLOR,VENUS_ORBITAL_PERIOD,VENUS_DISTANCE));var earthPose=new Float32Array([1,0,0,0,1,1]);let EARTH_SIZE=0.02;let EARTH_COLOR=[0.0/255,75.0/255,255.0/255,1];let EARTH_ORBITAL_PERIOD=365.0/365.0*60.0;let EARTH_DISTANCE=0.14;await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,earthPose,sunPose,EARTH_SIZE,EARTH_COLOR,EARTH_ORBITAL_PERIOD,EARTH_DISTANCE));var moonPose=new Float32Array([1,0,0,0,1,1]);let MOON_SIZE=0.005;let MOON_COLOR=[255.0/255,255.0/255,255.0/255,1];let MOON_ORBITAL_PERIOD=27.0/365.0*60.0;let MOON_DISTANCE=0.017;await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,moonPose,earthPose,MOON_SIZE,MOON_COLOR,MOON_ORBITAL_PERIOD,MOON_DISTANCE,0));var marsPose=new Float32Array([1,0,0,0,1,1]);let MARS_SIZE=0.016;let MARS_COLOR=[150.0/255,0.0/255,0.0/255,1];let MARS_ORBITAL_PERIOD=687.0/365.0*60.0;let MARS_DISTANCE=0.18;await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,marsPose,sunPose,MARS_SIZE,MARS_COLOR,MARS_ORBITAL_PERIOD,MARS_DISTANCE));var jupiterPose=new Float32Array([1,0,0,0,1,1]);let JUPITER_SIZE=0.05;let JUPITER_COLOR=[255.0/255,189.0/255,129.0/255,1];let JUPITER_ORBITAL_PERIOD=4333.0/365.0*60.0;let JUPITER_DISTANCE=0.24;await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,jupiterPose,sunPose,JUPITER_SIZE,JUPITER_COLOR,JUPITER_ORBITAL_PERIOD,JUPITER_DISTANCE));var redspotPose=new Float32Array([1,0,0,0,1,1]);let REDSPOT_SIZE=0.014;let REDSPOT_COLOR=[255.0/255,0.0/255,0.0/255,0.8];let REDSPOT_ORBITAL_PERIOD=10.0/(365.0)*60.0;let REDSPOT_DISTANCE=0.014;await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,redspotPose,jupiterPose,REDSPOT_SIZE,REDSPOT_COLOR,REDSPOT_ORBITAL_PERIOD,REDSPOT_DISTANCE,0));var saturnRingRear=new Float32Array([-0.055,0.02,255.0/255,255.0/255,230.0/255,1,-0.055,0.01,255.0/255,255.0/255,230.0/255,1,0.055,0.02,255.0/255,255.0/255,230.0/255,1,-0.055,0.01,255.0/255,255.0/255,230.0/255,1,0.055,0.02,255.0/255,255.0/255,230.0/255,1,0.055,0.01,255.0/255,255.0/255,230.0/255,1,]);var saturnRingLeft=new Float32Array([-0.055,0.02,255.0/255,255.0/255,230.0/255,1,-0.045,0.02,255.0/255,255.0/255,230.0/255,1,-0.055,-0.02,255.0/255,255.0/255,230.0/255,1,-0.045,0.02,255.0/255,255.0/255,230.0/255,1,-0.055,-0.02,255.0/255,255.0/255,230.0/255,1,-0.045,-0.02,255.0/255,255.0/255,230.0/255,1,]);var saturnRingRight=new Float32Array([0.045,0.02,255.0/255,255.0/255,230.0/255,1,0.055,0.02,255.0/255,255.0/255,230.0/255,1,0.045,-0.02,255.0/255,255.0/255,230.0/255,1,0.055,0.02,255.0/255,255.0/255,230.0/255,1,0.045,-0.02,255.0/255,255.0/255,230.0/255,1,0.055,-0.02,255.0/255,255.0/255,230.0/255,1,]);var saturnRingFront=new Float32Array([-0.055,-0.01,255.0/255,255.0/255,230.0/255,1,-0.055,-0.02,255.0/255,255.0/255,230.0/255,1,0.055,-0.02,255.0/255,255.0/255,230.0/255,1,-0.055,-0.01,255.0/255,255.0/255,230.0/255,1,0.055,-0.02,255.0/255,255.0/255,230.0/255,1,0.055,-0.01,255.0/255,255.0/255,230.0/255,1,]);var saturnPose=new Float32Array([1,0,0,0,1,1]);let SATURN_SIZE=0.044;let SATURN_COLOR=[255.0/255,233.0/255,94.0/255,1];let SATURN_ORBITAL_PERIOD=10756.0/365.0*60.0;let SATURN_DISTANCE=0.3;await renderer.appendSceneObject(new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,saturnRingRear,saturnPose));await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,saturnPose,sunPose,SATURN_SIZE,SATURN_COLOR,SATURN_ORBITAL_PERIOD,SATURN_DISTANCE));await renderer.appendSceneObject(new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,saturnRingLeft,saturnPose));await renderer.appendSceneObject(new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,saturnRingRight,saturnPose));await renderer.appendSceneObject(new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,saturnRingFront,saturnPose));var uranusPose=new Float32Array([1,0,0,0,1,1]);let URANUS_SIZE=0.038;let URANUS_COLOR=[0.0/255,200.0/255,255.0/255,1];let URANUS_ORBITAL_PERIOD=30867.0/365.0*60.0;let URANUS_DISTANCE=0.35;await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,jupiterPose,sunPose,URANUS_SIZE,URANUS_COLOR,URANUS_ORBITAL_PERIOD,URANUS_DISTANCE));var neptunePose=new Float32Array([1,0,0,0,1,1]);let NEPTUNE_SIZE=0.034;let NEPTUNE_COLOR=[0.0/255,0.0/255,255.0/255,1];let NEPTUNE_ORBITAL_PERIOD=60186.0/365.0*60.0;let NEPTUNE_DISTANCE=0.4;await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,jupiterPose,sunPose,NEPTUNE_SIZE,NEPTUNE_COLOR,NEPTUNE_ORBITAL_PERIOD,NEPTUNE_DISTANCE));var ufoBase=new Float32Array([-0.1,-0.025,0.7,0.7,0.7,1,0.1,-0.025,0.7,0.7,0.7,1,0,-0.04,0.7,0.7,0.7,1,]);var ufoBody=new Float32Array([-0.1,-0.025,0.8,0.8,0.8,1,-0.1,0.025,0.8,0.8,0.8,1,0.1,-0.025,0.8,0.8,0.8,1,-0.1,0.025,0.8,0.8,0.8,1,0.1,-0.025,0.8,0.8,0.8,1,0.1,0.025,0.8,0.8,0.8,1]);var ufoHead=new Float32Array([-0.08,0,0,1,0,1,-0.08,0.05,0,1,0,1,0.08,0,0,1,0,1,-0.08,0.05,0,1,0,1,0.08,0,0,1,0,1,0.08,0.05,0,1,0,1]);var ufoPose=new Float32Array([1,0,-0.25,0,1,1]);await renderer.appendSceneObject(new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,ufoBase,ufoPose));await renderer.appendSceneObject(new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,ufoBody,ufoPose));await renderer.appendSceneObject(new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,ufoHead,ufoPose));let angle=Math.PI/100;let center=[0,0];let dr=PGA2D.normalizeMotor([Math.cos(angle/2),-Math.sin(angle/2),-center[0]*Math.sin(angle/2),-center[1]*Math.sin(angle/2)]);function getRandomFrom(a,b){if(b<a)return Math.random();let range=b-a;let rand=range*Math.random()+a;return rand;}
var time=0;let interval=50;var ufoInitial=[...ufoPose];var ufoFinal=[1,0,getRandomFrom(-0.4,0.4),getRandomFrom(-0.4,0.4),1,1];setInterval(()=>{renderer.render();let newmotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[sunPose[0],sunPose[1],sunPose[2],sunPose[3]]));sunPose[0]=newmotor[0];sunPose[1]=newmotor[1];sunPose[2]=newmotor[2];sunPose[3]=newmotor[3];sunFlarePose[0]=newmotor[0];sunFlarePose[1]=-newmotor[1];sunFlarePose[2]=newmotor[2];sunFlarePose[3]=newmotor[3];if(time>=interval){ufoInitial=ufoFinal;ufoFinal=[1,0,getRandomFrom(-0.4,0.4),getRandomFrom(-0.4,0.4),1,1];time=0;}
ufoPose[0]=ufoInitial[0]*(1-time/interval)*(1-time/interval)+ufoFinal[0]*(time/interval)*(time/interval);let velocity_direction=ufoPose[3]-(ufoInitial[3]*(1-time/interval)*(1-time/interval)+ufoFinal[3]*(time/interval)*(time/interval));let velocity_magnitude=25-25*ufoPose[0];ufoPose[1]=velocity_direction*velocity_magnitude;ufoPose[2]=ufoInitial[2]*(1-time/interval)*(1-time/interval)+ufoFinal[2]*(time/interval)*(time/interval);ufoPose[3]=ufoInitial[3]*(1-time/interval)*(1-time/interval)+ufoFinal[3]*(time/interval)*(time/interval);time+=1;},100);return renderer;}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});