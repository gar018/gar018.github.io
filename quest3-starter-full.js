class Renderer{constructor(canvas){this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:0/255,b:0/255,a:1};}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this._canvas.style.transformOrigin="center";this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});for(const obj of this._objects){obj?.render(pass);}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class PGA2D{static geometricProduct(a,b){return[a[0]*b[0]-a[1]*b[1],a[0]*b[1]+a[1]*b[0],a[0]*b[2]+a[1]*b[3]+a[2]*b[0]-a[3]*b[1],a[0]*b[3]-a[1]*b[2]+a[2]*b[1]+a[3]*b[0]];}
static reverse(a){return[a[0],-a[1],-a[2],-a[3]];}
static applyMotor(p,m){return PGA2D.geometricProduct(m,PGA2D.geometricProduct(p,PGA2D.reverse(m)));}
static motorNorm(m){return Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]+m[3]*m[3]);}
static createTranslator(dx,dy){return[1,0,dy/2,-dx/2]}
static createRotor(angle,cx=0,cy=0){return[Math.cos(angle/2),-Math.sin(angle/2),-cx*Math.sin(angle/2),-cy*Math.sin(angle/2)];}
static normalizeMotor(m){let mnorm=PGA2D.motorNorm(m);if(mnorm==0.0){return[1,0,0,0];}
return[m[0]/mnorm,m[1]/mnorm,m[2]/mnorm,m[3]/mnorm];}
static applyMotorToPoint(p,m){let new_p=PGA2D.applyMotor([0,1,p[0],p[1]],m);return[new_p[2]/new_p[1],new_p[3]/new_p[1]];};}
class Camera{constructor(){this._pose=new Float32Array([1,0,0,0,1,1]);}
resetPose(){this._pose[0]=1;this._pose[1]=0;this._pose[2]=0;this._pose[3]=0;this._pose[4]=1;this._pose[5]=1;}
updatePose(newpose){this._pose[0]=newpose[0];this._pose[1]=newpose[1];this._pose[2]=newpose[2];this._pose[3]=newpose[3];}
moveLeft(d){let dt=PGA2D.createTranslator(-d,0);let newpose=PGA2D.normalizeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveRight(d){let dt=PGA2D.createTranslator(d,0);let newpose=PGA2D.normalizeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveUp(d){let dt=PGA2D.createTranslator(0,d);let newpose=PGA2D.normalizeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveDown(d){let dt=PGA2D.createTranslator(0,-d);let newpose=PGA2D.normalizeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
zoomIn(){this._pose[4]*=1.1;this._pose[5]*=1.1;}
zoomOut(){this._pose[4]/=1.1;this._pose[5]/=1.1;}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){throw new Error("Method 'createShaders()' must be implemented.");}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}}
class CameraLineStrip2DAliveDeadObject extends SceneObject{constructor(device,canvasFormat,cameraPose,vertices,cellStatus){super(device,canvasFormat);this._cameraPose=cameraPose;this._cellStatus=cellStatus
this._gridSize=new Uint32Array([Math.floor(Math.sqrt(cellStatus.length))]);if(typeof this._vertices===Float32Array)this._vertices=vertices;else this._vertices=new Float32Array(vertices);}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,}],};this._cameraPoseBuffer=this._device.createBuffer({label:"Camera Pose "+this.getName(),size:this._cameraPose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);this._cellStateBuffers=[this._device.createBuffer({label:"Grid status Buffer 1 "+this.getName(),size:this._cellStatus.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,}),this._device.createBuffer({label:"Grid status Buffer 2 "+this.getName(),size:this._cellStatus.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,})];this._step=0;this.reset();this._gridSizeBuffer=this._device.createBuffer({label:"Grid Size Buffer "+this.getName(),size:this._gridSize.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._gridSizeBuffer,0,this._gridSize);}
reset(){this._step=0;this._cellStatus=new Uint32Array(this._cellStatus.length);for(let i=0;i<this._cellStatus.length/2;i++){let index=Math.floor(Math.random()*this._cellStatus.length);this._cellStatus[index]=1;}
this._device.queue.writeBuffer(this._cellStateBuffers[0],0,this._cellStatus);this._device.queue.writeBuffer(this._cellStateBuffers[1],0,this._cellStatus);}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_camera2dalivedead.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});this._bindGroupLayout=this._device.createBindGroupLayout({label:"Grid Bind Group Layout "+this.getName(),entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{}}]});this._pipelineLayout=this._device.createPipelineLayout({label:"Grid Pipeline Layout",bindGroupLayouts:[this._bindGroupLayout],});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:this._pipelineLayout,vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]},primitive:{topology:'triangle-strip'}});this._bindGroups=[this._device.createBindGroup({label:"Renderer Bind Group 1 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[0]}},{binding:2,resource:{buffer:this._cellStateBuffers[1]}},{binding:3,resource:{buffer:this._gridSizeBuffer}}],}),this._device.createBindGroup({label:"Renderer Bind Group 2 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[1]}},{binding:2,resource:{buffer:this._cellStateBuffers[0]}},{binding:3,resource:{buffer:this._gridSizeBuffer}}],})];}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.draw(this._vertices.length/2,this._gridSize[0]*this._gridSize[0]);}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Grid update pipeline "+this.getName(),layout:this._pipelineLayout,compute:{module:this._shaderModule,entryPoint:"computeMain",}});}
compute(pass){pass.setPipeline(this._computePipeline);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.dispatchWorkgroups(Math.ceil(this._gridSize[0]/8),Math.ceil(this._gridSize[0]/8));++this._step;}}
class StandardTextObject{constructor(inputText,spacing=5,textFont='18px Arial'){this._textFont=textFont;this._lineSpacing=spacing;this._textCanvas=document.createElement('canvas');this._textContext=this._textCanvas.getContext('2d');this.updateTextRegion(inputText);this.updateText(inputText);this._textCanvas.style.position='absolute';this._textCanvas.style.top='10px';this._textCanvas.style.left='10px';this._textCanvas.style.border='1px solid red';document.body.appendChild(this._textCanvas);}
toggleVisibility(){this._textCanvas.hidden=!this._textCanvas.hidden;}
updateTextRegion(newText){this._textContext.font=this._textFont;this._lines=newText.split('\n');this._width=Math.max(...this._lines.map(line=>this._textContext.measureText(line).width));const match=this._textFont.match(/(\d+)px/);if(match){this._fontSize=parseInt(match[1],10);}
else{this._fontSize=18;this._textFont="18px Arial";}
this._height=this._lines.length*(this._fontSize+this._lineSpacing);this._paddingx=5;this._paddingtop=3;this._canvasWidth=Math.ceil(this._width+this._paddingx*2);this._canvasHeight=Math.ceil(this._height+this._paddingtop);this._textCanvas.width=this._canvasWidth;this._textCanvas.height=this._canvasHeight;this._textContext.font=this._textFont;this._textContext.textBaseline='top';}
updateText(newText){this._lines=newText.split('\n');this._textContext.fillStyle='rgba(1, 1, 1, 0.5)';this._textContext.clearRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillStyle='white';this._lines.forEach((line,idx)=>{const x=this._paddingx;const y=this._paddingtop+idx*(this._fontSize+this._lineSpacing);this._textContext.fillText(line,x,y);});}}/*Copyright(c)2025 SingChun LEE@Bucknell University.CC BY-NC 4.0.**This code is provided mainly for educational purposes at Bucknell University.**This code is licensed under the Creative Commons Attribution-NonCommerical 4.0*International License.To view a copy of the license,visit*https:*or send a letter to Creative Commons,PO Box 1866,Mountain View,CA 94042,USA.**You are free to:*-Share:copy and redistribute the material in any medium or format.*-Adapt:remix,transform,and build upon the material.**Under the following terms:*-Attribution:You must give appropriate credit,provide a link to the license,*and indicate if changes where made.*-NonCommerical:You may not use the material for commerical purposes.*-No additional restrictions:You may not apply legal terms or technological*measures that legally restrict others from doing*anything the license permits.*/class Standard2DPGAPosedVertexColorObject extends SceneObject{constructor(device,canvasFormat,cameraPose,vertices,pose){super(device,canvasFormat);this._vertices=vertices;this._pose=pose;this._cameraPose=cameraPose;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,},{shaderLocation:1,format:"float32x4",offset:2*Float32Array.BYTES_PER_ELEMENT,}],};this._poseBuffer=this._device.createBuffer({label:"Pose "+this.getName(),size:this._pose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);this._cameraPoseBuffer=this._device.createBuffer({label:"Camera Pose "+this.getName(),size:this._cameraPose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
updateGeometry(){this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2dpgacamera.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._bindGroup=this._device.createBindGroup({label:"Render Bind Group "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._poseBuffer},},{binding:1,resource:{buffer:this._cameraPoseBuffer}}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroup);pass.draw(this._vertices.length/6);}
async createComputePipeline(){}
compute(pass){}}
async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const renderer=new Renderer(canvasTag);await renderer.init();const camera=new Camera();camera._pose[4]=4;camera._pose[5]=4;let q=1.;var verticesQuad=new Float32Array([-q,-q,q,-q,-q,q,-q,q,q,-q,q,q]);let gridSize=2048;let cellStatus=new Uint32Array(gridSize*gridSize);const grid=new CameraLineStrip2DAliveDeadObject(renderer._device,renderer._canvasFormat,camera._pose,verticesQuad,cellStatus);await renderer.appendSceneObject(grid);var pose=new Float32Array([1,0,0,0,0.025,0.025]);var quadVertices=new Float32Array([-1,-1,1,0,0,1,1,-1,0,1,0,1,-1,1,0,0,1,1,1,1,1,0,1,1,-1,1,0,0,1,1,1,-1,0,1,0,1]);let fps='??';var fpsText=new StandardTextObject('fps: '+fps);var wasdText=new StandardTextObject('Use \'W/A/S/D\' to move around.');wasdText._textCanvas.style.top='40px';var zoomText=new StandardTextObject('Use \'Q/E\' to zoom in/out.');zoomText._textCanvas.style.top='70px';var resetText=new StandardTextObject('Use \'R\' to reset the grid.');resetText._textCanvas.style.top='100px';var fullscreenText=new StandardTextObject('Use \'F\' to enter fullscreen.');fullscreenText._textCanvas.style.top='130px';var movespeed=0.02;var animationSpeed=6;var isPlaying=1;var fullScreenMode=false;var returnPose=[1,0,0,0,1,1];window.addEventListener("keydown",(e)=>{switch(e.key){case'ArrowUp':case'w':case'W':if(camera._pose[2]<0.30&&fullScreenMode==false){camera.moveUp(movespeed);grid.updateCameraPose();}
break;case'ArrowDown':case's':case'S':if(camera._pose[2]>-0.30&&fullScreenMode==false){camera.moveDown(movespeed);grid.updateCameraPose();}
break;case'ArrowLeft':case'a':case'A':if(camera._pose[3]<0.30&&fullScreenMode==false){camera.moveLeft(movespeed);grid.updateCameraPose();}
break;case'ArrowRight':case'd':case'D':if(camera._pose[3]>-0.30&&fullScreenMode==false){camera.moveRight(movespeed);grid.updateCameraPose();}
break;case'r':case'R':grid.reset();break;case'q':case'Q':if(camera._pose[4]<10&&camera._pose[5]<10&&fullScreenMode==false){camera.zoomIn();grid.updateCameraPose();}
break;case'e':case'E':if(camera._pose[4]>4&&camera._pose[5]>4&&fullScreenMode==false){camera.zoomOut();grid.updateCameraPose();}
break;case'f':case'F':fpsText.toggleVisibility();wasdText.toggleVisibility();zoomText.toggleVisibility();resetText.toggleVisibility();fullscreenText.toggleVisibility();if(fullScreenMode==false){returnPose=[...camera._pose];camera.updatePose([1,0,0,0,1,1]);camera._pose[4]=1;camera._pose[5]=1;grid.updateCameraPose();fullScreenMode=true;}
else{camera.updatePose([...returnPose]);camera._pose[4]=returnPose[4];camera._pose[5]=returnPose[5];grid.updateCameraPose();fullScreenMode=false;}
break;}});var frameCnt=0;var tgtFPS=60;var secPerFrame=1./tgtFPS;var frameInterval=secPerFrame*1000;var lastCalled;let renderFrame=()=>{let elapsed=Date.now()-lastCalled;if(elapsed>frameInterval){++frameCnt;lastCalled=Date.now()-(elapsed%frameInterval);renderer.render();}
requestAnimationFrame(renderFrame);};lastCalled=Date.now();renderFrame();setInterval(()=>{fpsText.updateText('fps: '+frameCnt);frameCnt=0;},1000);return renderer;}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});
